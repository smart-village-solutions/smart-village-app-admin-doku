#!/usr/bin/env python3
"""
Module Finalization Tool

Schritt 3 des neuen Workflows: Finalisiert ein DRAFT-Modul nach menschlicher Freigabe.
- Entfernt DRAFT-Prefix
- Führt Validierung durch
- Generiert finale YAML
- Registriert in city_app.yml
- Optional: Git-Workflow (Branch, Commits, PR)

Usage:
    python scripts/finalize_module.py --name abfallkalender --full
    python scripts/finalize_module.py --name push --no-git
    python scripts/finalize_module.py --name karten --no-pr
"""

import argparse
import sys
import yaml
import json
import subprocess
import shutil
from pathlib import Path
from typing import Dict, Any, Optional
from jsonschema import validate, ValidationError
from datetime import datetime

# ANSI color codes
GREEN = '\033[92m'
YELLOW = '\033[93m'
BLUE = '\033[94m'
CYAN = '\033[96m'
RED = '\033[91m'
BOLD = '\033[1m'
RESET = '\033[0m'


def load_yaml(path: Path) -> Dict[str, Any]:
    """Lädt YAML-Datei."""
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)


def save_yaml(path: Path, data: Dict[str, Any], header: Optional[str] = None):
    """Speichert YAML-Datei mit optionalem Header."""
    with open(path, 'w', encoding='utf-8') as f:
        if header:
            f.write(header)
        yaml.dump(data, f, allow_unicode=True, sort_keys=False, default_flow_style=False)


def load_schema(schema_path: Path) -> Dict[str, Any]:
    """Lädt JSON Schema."""
    with open(schema_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def validate_module(data: Dict[str, Any], schema: Dict[str, Any]) -> tuple[bool, list]:
    """Validiert Modul gegen Schema."""
    errors = []
    try:
        validate(instance=data, schema=schema)
        return True, []
    except ValidationError as e:
        errors.append(str(e.message))
        return False, errors


def merge_with_global(module_data: Dict[str, Any], global_data: Dict[str, Any]) -> Dict[str, Any]:
    """Merged Modul-Daten mit global.yml."""
    result = {}

    # Schema-defined fields mit Defaults
    schema_defaults = {
        'development_status': 'In Entwicklung',
        'optional': False,
        'cost': 'Auf Anfrage'
    }

    # Start with schema defaults
    result.update(schema_defaults)

    # Override with global.yml common fields
    if 'common' in global_data:
        for key, value in global_data['common'].items():
            if key != 'name':  # name kommt nur aus Modul
                result[key] = value

    # Override with module-specific
    result.update(module_data)

    return result


def generate_final_yaml(name: str, draft_data: Dict[str, Any], global_data: Dict[str, Any],
                        yml_dir: Path) -> Path:
    """Generiert finale YAML aus DRAFT + global.yml."""
    merged_data = merge_with_global(draft_data, global_data)

    # Header für generierte Datei
    header = f"""# AUTO-GENERATED FROM yml/modules/{name}.yml + yml/global.yml
# Do not edit this file directly. Edit yml/modules/{name}.yml instead.
# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""

    final_path = yml_dir / f"{name}.yml"
    save_yaml(final_path, merged_data, header)

    return final_path


def register_in_city_app(name: str, city_app_path: Path) -> bool:
    """Registriert Modul in city_app.yml."""
    try:
        with open(city_app_path, 'r', encoding='utf-8') as f:
            content = f.read()
            city_app = yaml.safe_load(content)

        module_url = f"https://raw.githubusercontent.com/smart-village-solutions/smart-village-app-admin-doku/main/yml/{name}.yml"

        if 'modules' not in city_app:
            city_app['modules'] = []

        if module_url not in city_app['modules']:
            city_app['modules'].append(module_url)

            # Preserve original formatting
            lines = content.split('\n')
            modules_idx = None
            for i, line in enumerate(lines):
                if line.strip().startswith('modules:'):
                    modules_idx = i
                    break

            if modules_idx is not None:
                # Add new URL at the end of modules list
                indent = '  '
                new_line = f"{indent}- {module_url}"

                # Find last module entry
                last_module_idx = modules_idx
                for i in range(modules_idx + 1, len(lines)):
                    if lines[i].strip().startswith('-'):
                        last_module_idx = i
                    elif lines[i].strip() and not lines[i].strip().startswith('#'):
                        break

                lines.insert(last_module_idx + 1, new_line)

                with open(city_app_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(lines))

                return True

        return False  # Already registered

    except Exception as e:
        print(f"{RED}Fehler bei city_app.yml Registrierung: {e}{RESET}")
        return False


def git_create_branch(name: str) -> bool:
    """Erstellt Git Feature-Branch."""
    branch_name = f"feature/module-{name}"

    try:
        # Check if branch exists
        result = subprocess.run(['git', 'branch', '--list', branch_name],
                              capture_output=True, text=True)
        if result.stdout.strip():
            print(f"{YELLOW}Branch {branch_name} existiert bereits{RESET}")
            # Checkout existing branch
            subprocess.run(['git', 'checkout', branch_name], check=True)
            return True

        # Create new branch
        subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
        print(f"{GREEN}✓ Branch erstellt: {branch_name}{RESET}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"{RED}Git-Fehler: {e}{RESET}")
        return False


def git_commit(message: str, files: list) -> bool:
    """Erstellt Git-Commit."""
    try:
        subprocess.run(['git', 'add'] + files, check=True)
        subprocess.run(['git', 'commit', '-m', message], check=True)
        print(f"{GREEN}✓ Commit: {message}{RESET}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"{RED}Git-Fehler: {e}{RESET}")
        return False


def git_push(branch_name: str) -> bool:
    """Pushed Branch zu Remote."""
    try:
        subprocess.run(['git', 'push', '-u', 'origin', branch_name], check=True)
        print(f"{GREEN}✓ Branch gepusht: {branch_name}{RESET}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"{RED}Git-Fehler: {e}{RESET}")
        return False


def create_pull_request(name: str, description: str) -> bool:
    """Erstellt Pull Request via GitHub CLI."""
    title = f"feat(module): Add {name} module description"

    # Check if gh CLI is available
    if subprocess.run(['which', 'gh'], capture_output=True).returncode != 0:
        print(f"{YELLOW}GitHub CLI nicht gefunden. PR muss manuell erstellt werden.{RESET}")
        print(f"{CYAN}URL: https://github.com/smart-village-solutions/smart-village-app-admin-doku/pulls{RESET}")
        return False

    try:
        result = subprocess.run([
            'gh', 'pr', 'create',
            '--title', title,
            '--body', description,
            '--base', 'main'
        ], check=True, capture_output=True, text=True)

        print(f"{GREEN}✓ Pull Request erstellt{RESET}")
        print(f"{CYAN}{result.stdout.strip()}{RESET}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"{RED}GitHub CLI Fehler: {e}{RESET}")
        if e.stderr:
            print(f"{RED}{e.stderr.decode()}{RESET}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Finalisiert DRAFT-Modul nach menschlicher Freigabe (Schritt 3: Finalize)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Beispiele:
  %(prog)s --name push-nachrichten --full
  %(prog)s --name abfallkalender --no-git
  %(prog)s --name karten --no-pr

Modi:
  --full:    Kompletter Workflow (DRAFT → Final + Git + PR) [default]
  --no-git:  Nur DRAFT → Final (keine Git-Aktionen)
  --no-pr:   DRAFT → Final + Git (ohne PR)
        """
    )
    parser.add_argument('--name', required=True, help='Name des Moduls')
    parser.add_argument('--full', action='store_true', default=True,
                       help='Kompletter Workflow (default)')
    parser.add_argument('--no-git', action='store_true',
                       help='Keine Git-Aktionen (nur Dateien)')
    parser.add_argument('--no-pr', action='store_true',
                       help='Kein Pull Request (nur Branch + Commits)')

    args = parser.parse_args()

    # Paths
    root_dir = Path(__file__).parent.parent
    draft_path = root_dir / 'yml' / 'modules' / f"DRAFT-{args.name}.yml"
    final_module_path = root_dir / 'yml' / 'modules' / f"{args.name}.yml"
    global_path = root_dir / 'yml' / 'global.yml'
    schema_path = root_dir / 'schema' / 'app-module.schema.json'
    yml_dir = root_dir / 'yml'
    city_app_path = root_dir / 'city_app.yml'

    print(f"{BOLD}{CYAN}=== Module Finalization ==={RESET}\n")
    print(f"Finalisiere Modul: {BOLD}{args.name}{RESET}")

    # Check if DRAFT exists
    if not draft_path.exists():
        print(f"\n{RED}✗ DRAFT-{args.name}.yml nicht gefunden!{RESET}")
        print(f"{YELLOW}Führe zuerst den Review durch:{RESET}")
        print(f"  python scripts/review_module.py --name {args.name}")
        return 1

    # Load files
    try:
        draft_data = load_yaml(draft_path)
        global_data = load_yaml(global_path)
        schema = load_schema(schema_path)
    except Exception as e:
        print(f"{RED}Fehler beim Laden: {e}{RESET}")
        return 1

    # Validate DRAFT
    print(f"\n{BOLD}Schritt 1: Validierung{RESET}")
    is_valid, errors = validate_module(draft_data, schema)

    if not is_valid:
        print(f"{RED}✗ Validierung fehlgeschlagen:{RESET}")
        for error in errors:
            print(f"  {RED}•{RESET} {error}")
        return 1

    print(f"{GREEN}✓ DRAFT validiert{RESET}")

    # Git Branch (if enabled)
    if not args.no_git:
        print(f"\n{BOLD}Schritt 2: Git Branch{RESET}")
        if not git_create_branch(args.name):
            print(f"{RED}Git-Branch Fehler. Fortfahren ohne Git? (y/n){RESET}")
            if input().lower() != 'y':
                return 1
            args.no_git = True

    # Move DRAFT to final
    print(f"\n{BOLD}Schritt 3: Finalisiere Modul-Partial{RESET}")
    try:
        shutil.move(str(draft_path), str(final_module_path))

        # Remove DRAFT header, add final header
        with open(final_module_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Remove DRAFT header
        lines = content.split('\n')
        clean_lines = []
        in_header = True
        for line in lines:
            if in_header and (line.startswith('#') or not line.strip()):
                continue
            else:
                in_header = False
                clean_lines.append(line)

        # Add final header
        final_header = f"""# Module Partial: {args.name}
# This partial is merged with yml/global.yml to generate yml/{args.name}.yml
# Last updated: {datetime.now().strftime('%Y-%m-%d')}

"""
        with open(final_module_path, 'w', encoding='utf-8') as f:
            f.write(final_header + '\n'.join(clean_lines))

        print(f"{GREEN}✓ Modul-Partial finalisiert: yml/modules/{args.name}.yml{RESET}")
    except Exception as e:
        print(f"{RED}Fehler beim Finalisieren: {e}{RESET}")
        return 1

    # Commit 1 (if Git enabled)
    if not args.no_git:
        git_commit(f"feat(module): add {args.name} partial",
                  [str(final_module_path.relative_to(root_dir))])

    # Generate final YAML
    print(f"\n{BOLD}Schritt 4: Generiere finale YAML{RESET}")
    try:
        final_yaml_path = generate_final_yaml(args.name, draft_data, global_data, yml_dir)
        print(f"{GREEN}✓ Finale YAML generiert: yml/{args.name}.yml{RESET}")
    except Exception as e:
        print(f"{RED}Fehler bei YAML-Generierung: {e}{RESET}")
        return 1

    # Commit 2 (if Git enabled)
    if not args.no_git:
        git_commit(f"feat(module): generate {args.name} complete YAML",
                  [str(final_yaml_path.relative_to(root_dir))])

    # Register in city_app.yml
    print(f"\n{BOLD}Schritt 5: Registriere in city_app.yml{RESET}")
    registered = register_in_city_app(args.name, city_app_path)
    if registered:
        print(f"{GREEN}✓ In city_app.yml registriert{RESET}")
    else:
        print(f"{YELLOW}○ Bereits in city_app.yml registriert{RESET}")

    # Commit 3 (if Git enabled)
    if not args.no_git and registered:
        git_commit(f"feat(module): register {args.name} in city_app.yml",
                  [str(city_app_path.relative_to(root_dir))])

    # Push branch
    if not args.no_git:
        print(f"\n{BOLD}Schritt 6: Push Branch{RESET}")
        branch_name = f"feature/module-{args.name}"
        if not git_push(branch_name):
            print(f"{YELLOW}Push fehlgeschlagen. Manuell pushen:{RESET}")
            print(f"  git push -u origin {branch_name}")

    # Create PR (if enabled)
    if not args.no_git and not args.no_pr:
        print(f"\n{BOLD}Schritt 7: Erstelle Pull Request{RESET}")
        pr_body = f"""## Modul: {args.name}

**Topic:** {draft_data.get('topic', 'N/A')}

**Kurzbeschreibung:**
{draft_data.get('short_description', 'N/A')}

**Hauptszenario:**
{draft_data.get('usage_scenario', 'N/A')}

---

### Checkliste
- [x] Modul validiert gegen Schema
- [x] Generierte YAML erstellt
- [x] In city_app.yml registriert
- [ ] Review durch Maintainer

### Dateien
- `yml/modules/{args.name}.yml` - Modul-Partial
- `yml/{args.name}.yml` - Generierte YAML
- `city_app.yml` - Registrierung
"""
        create_pull_request(args.name, pr_body)

    # Summary
    print(f"\n{BOLD}{GREEN}=== Finalisierung abgeschlossen ==={RESET}\n")
    print(f"{GREEN}✓{RESET} Modul-Partial: {CYAN}yml/modules/{args.name}.yml{RESET}")
    print(f"{GREEN}✓{RESET} Finale YAML: {CYAN}yml/{args.name}.yml{RESET}")
    print(f"{GREEN}✓{RESET} Registriert in: {CYAN}city_app.yml{RESET}")

    if not args.no_git:
        print(f"{GREEN}✓{RESET} Git Branch: {CYAN}feature/module-{args.name}{RESET}")
        if not args.no_pr:
            print(f"{GREEN}✓{RESET} Pull Request erstellt")

    print(f"\n{BOLD}Nächste Schritte:{RESET}")
    if not args.no_pr:
        print(f"  1. Review PR auf GitHub")
        print(f"  2. Merge nach Freigabe")
    else:
        print(f"  1. Erstelle PR manuell oder merge direkt")
    print(f"  3. Module ist produktiv verfügbar!")

    return 0


if __name__ == '__main__':
    sys.exit(main())
